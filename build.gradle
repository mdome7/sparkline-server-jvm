group 'tech.labs2160'
version '1.0-SNAPSHOT'

repositories {
  mavenLocal()
  mavenCentral()
}

ext {
  versions = [
      _scala      : '2.11',
      scala       : '2.11.7',
      scalatest   : '2.2.6',
      jetty       : '9.3.8.v20160314',
      jersey      : '2.15',
      scalaLogging: '3.4.0',
      batik       : '1.9.1' // do not use 1.8 - that version has issues
  ]

  props = [
      LOG_DIR     : "/var/log/${project.name}",
      APP_NAME    : project.name,
      API_PORT    : 8080
  ]

  docker = [
      repoName            : "${project.group}/${project.name}",
      imageTag            : "${project.version}",
      imageFullName       : "${project.group}/${project.name}:${project.version}",

      defaultParams       : "-d -p 20080:${props.API_PORT}",
      containerName       : "${project.name}"
  ]
}

println "Project: $name"

apply plugin: 'application'
apply plugin: 'scala'
apply plugin: 'idea'
apply plugin: 'distribution'
apply plugin: 'docker'

sourceCompatibility = 1.8
targetCompatibility = 1.8

dependencies {
  compile "org.scala-lang:scala-library:${versions.scala}"
  compile "org.eclipse.jetty:jetty-server:${versions.jetty}"
  compile "org.eclipse.jetty:jetty-servlet:${versions.jetty}"
  compile "org.eclipse.jetty:jetty-servlets:${versions.jetty}"
  compile "com.typesafe.scala-logging:scala-logging_${versions._scala}:${versions.scalaLogging}"
  compile "org.glassfish.jersey.core:jersey-server:${versions.jersey}"
  compile "org.glassfish.jersey.containers:jersey-container-servlet:${versions.jersey}"
  compile "javax.ws.rs:javax.ws.rs-api:2.0.1"
  compile "org.apache.commons:commons-io:1.3.2"
  compile "org.apache.xmlgraphics:batik-transcoder:${versions.batik}"
  compile "org.apache.xmlgraphics:batik-codec:${versions.batik}"

  compile "ch.qos.logback:logback-classic:1.1.7"
  testCompile "org.scalatest:scalatest_${versions._scala}:2.2.6"
  testCompile 'junit:junit:4.12'
}

// ------------
//   CONFIG
// ------------

mainClassName = "com.labs2160.sparklineserver.MainServer"


processResources {
  expand(props)
}

jar {
  manifest {
    attributes 'Main-Class': mainClassName
  }
}

buildscript {
  repositories { jcenter() }
  dependencies {
    classpath 'se.transmode.gradle:gradle-docker:1.2'
  }
}

docker {
  baseImage  'openjdk:8-jre-alpine'
  maintainer 'Michael Dometita "michael.dometita@gmail.com"'
}

// ------------
//   TASKS
// ------------

/**
 *
 * @param cmd
 * @param ignoreExitVal true if failures are tolerated
 * @param env map of environment variables to set before running the command
 * @return
 */
def execute(cmd, ignoreExitVal = false, env = ['app_name':project.name]) {
  println "Executing: ${cmd}"
  def out = new ByteArrayOutputStream()
  project.exec {
    environment = env
    ignoreExitValue = ignoreExitVal
    commandLine = cmd.tokenize(" ")
    standardOutput = out
  }
  println out.toString()
  return out.toString()
}


task slurp(type: JavaExec, dependsOn: classes) {
  main = mainClassName
  classpath sourceSets.main.runtimeClasspath
  classpath configurations.runtime
}

task scalaTest(dependsOn: ['testClasses'], type: JavaExec) {
  main = 'org.scalatest.tools.Runner'
  args = ['-R', 'build/classes/test', '-o']
  classpath = sourceSets.test.runtimeClasspath
}


task dockerBuild(type: Docker, dependsOn: installDist) {
  group "${project.name} - Docker"
  description 'Build the Docker image'

  applicationName = "${project.name}"
  tagVersion =      "${docker.imageTag}"

  def installDir = "${project.name}"
  def runScript = "${installDir}/bin/${project.name}"

  exposePort(props.API_PORT)

  addFile {
    from "${project.buildDir}/install/${project.name}"
    into "${installDir}"
  }
  runCommand "chmod +x /${runScript}"

  def cmd = ["/${runScript}"]
  defaultCommand(cmd)
}

task dockerRun {
  group "${project.name} - Docker"
  description 'Run the Docker image in a container'

  doLast {
    def testUrl = "http://localhost:${props.API_PORT}/api/sparkline.png?values=5,5,5,0,10,5,5,5&w=100&h=50"
    execute("docker rm -f ${docker.containerName}", true)
    execute("docker run -d -p ${props.API_PORT}:${props.API_PORT} --name ${docker.containerName} ${docker.imageFullName}")
    println("Test by pointing browser to: ${testUrl}")
  }
}

task dockerStop {
  group "${project.name} - Docker"
  description 'Stop the Docker container'

  doLast {
    execute("docker rm -f ${docker.containerName}", true)
  }
}